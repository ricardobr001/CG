<!-- Nomes: Caio Henrique Giacomelli		RAs: 620360
	 		Gabriela Ramos						 620360
			Ricardo Mendes Leal Junior		     562262 -->

<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Atividade Final- Computaçao Gráfica</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<script src="three.js"></script>
		<script src="MTLLoader.js"></script>
		<script src="OBJLoader.js"></script>


		<script id="vertex" type="x-shader/x-vertex">
		     varying vec2 vUv;
			void main()
			{
				vUv = uv;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;
			}
		</script>

		<script id="fragment" type="x-shader/x-fragment">
			uniform vec2 resolution;
			varying vec2 vUv;
			void main( void ) {
				vec2 position = -25.0 + 3.0 * vUv;
				float red = abs( sin( position.x * position.y ) );
				float green = abs( sin( position.x * position.y ) );
				float blue = abs( sin( position.x * position.y) );
				gl_FragColor = vec4( red, green, blue, 1.0 );
			}
    	</script>

		<button id= "ButtonCamera1">Camera 1</button>
		<button id= "ButtonCamera2">Camera 2</button>
		<script>
			/*Declaring variables*/
			var container, stats;
			var camera2, scene, renderer;
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			var obj_Woody;
			var obj_Lotso;
			var obj_Ball;
			var MovingCube;
			var bezier_curve;
			var count = 0, flag_lotso = true;
			var UNITWIDTH = 90;
			var UNITHEIGHT = 45;
			var ObjetosDeColisao = [];
			//var handler = THREE.AnimationHandler.CATMULLROM;
			var clock = new THREE.Clock();
			// Flags to determine which direction the player is moving
			var moveForward = false;
			var moveBackward = false;
			var moveLeft = false;
			var moveRight = false;
			var xSpeed = 0.01;
			var ySpeed = 0.01;
			var PLAYERCOLLISIONDISTANCE = 5;
			var skeleton, mesh;
    			init();
    			animate();
			function init(){
				/*Creating the new bezier curve*/
				bezier_curve = new THREE.CubicBezierCurve3(
					new THREE.Vector3(-2.4, -1.2, 0),		//Starting point
					new THREE.Vector3(-3.2, -4, 0),		//First control point
					new THREE.Vector3(-4, 0, 0),		//Second control point
					new THREE.Vector3(-4.8, -1.2, 0)			//Ending point
				);
				pontos = new THREE.Geometry();
				pontos.vertices = bezier_curve.getPoints(100);
				matrixWoody = new THREE.Matrix4();
				matrixWoody.set(
					0.707106781187,  0.707106781187,  0,  1.414213562374,
       				-0.707106781187,  0.707106781187,  0,  -1.414213562374,
       				0,  0,  1,  0,
       				0,  0,  0,  1
       			);
				/*Creating the camera matrix*/
				matrixCamera = new THREE.Matrix4();
				matrixCamera.set(
					1, 0, 0, -0.25,
					0, 1, 0, -0.5,
					0, 0, 1, 100,
				 	0, 0, 0, 1
				);
				/*Creating the Container*/
				container = document.createElement('div');
				document.body.appendChild(container);
				/*Creating the Scene*/
				scene = new THREE.Scene();
				/*Creating the camera and positioning it*/
				camera1 = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 3000);
				
				camera1.position.y = 580; // Height the camera will be looking from
			    camera1.position.x = 0;
			    camera1.position.z = 0;

			   	camera1.lookAt(scene.position);
				/*Utilizaçao de duas cameras */
				camera2 = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 3000);
				camera2.position.z = 480;
				camera2.position.y = 200;
				camera2.lookAt(new THREE.Vector3(0,0,0));
				/*Creating the ambient, light and adding it to the scene*/
				var ambient = new THREE.AmbientLight(0x444440);
				scene.add(ambient);
				var directionalLight = new THREE.DirectionalLight(0xffeedd);
				directionalLight.position.set(0, 1, 0).normalize();
				scene.add( directionalLight );
				/*Criando o labirinto*/
								var map = [
			        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1,1,1,1,1,],
			        [1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,1,1,1,1,1,],
			      	[1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1,1,0,0,1,],
			        [1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1,0,0,1,1,],
			        [1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1,0,0,1,1,],
			      	[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1,1,1,1,1,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
		        	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,]
			    ];
			    var sphGeo = new THREE.SphereGeometry( 9, 100, 100 );
				var sphMat = new THREE.MeshBasicMaterial( {color: 0xffff00} );
			    var widthOffset = UNITWIDTH / 5;
			    var heightOffset = UNITHEIGHT / 5;
			   var totalSphWide = map[0].length;
			   /*Adding spheres where value is 1*/
			    for (var i = 0; i < totalSphWide; i++) {
			        for (var j = 0; j < map[i].length; j++) {
			            if (map[i][j]) {
			                var sphere = new THREE.Mesh( sphGeo, sphMat );
			                sphere.position.z = (i - totalSphWide / 2) * UNITWIDTH + widthOffset*43;
			                sphere.position.y = 0;
			                sphere.position.x = (j - 11) * 20;
			                scene.add(sphere);
							/*Adding the sphere for colision detection later*/
							ObjetosDeColisao.push(sphere);
			            }
			        }
			    }
				 var materials = [
		       new THREE.MeshLambertMaterial({
		           map: THREE.ImageUtils.loadTexture('assets/back_toyStory.jpg'),
		           side: THREE.BackSide
		       }),
		       new THREE.MeshLambertMaterial({
		           map: THREE.ImageUtils.loadTexture('assets/back_toyStory.jpg'),
		           side: THREE.BackSide
		       }),
		       new THREE.MeshLambertMaterial({
		           map: THREE.ImageUtils.loadTexture('assets/back_toyStory.jpg'),
		           side: THREE.BackSide
		       }),
		       new THREE.MeshLambertMaterial({
		           map: THREE.ImageUtils.loadTexture('assets/chao.jpg'),
		           side: THREE.BackSide
		       }),
		       new THREE.MeshLambertMaterial({
		           map: THREE.ImageUtils.loadTexture('assets/back_toyStory.jpg'),
		           side: THREE.BackSide
		       }),
		       new THREE.MeshLambertMaterial({
		           map: THREE.ImageUtils.loadTexture('assets/back_toyStory.jpg'),
		           side: THREE.BackSide
		       })
		    ];
			dice = new THREE.Mesh( new THREE.BoxGeometry( 950,950,950), materials );
				dice.position.set(0,400,-100);
				scene.add( dice );
				var mtlLoader = new THREE.MTLLoader();
    	    	mtlLoader.setPath('assets/');
            	mtlLoader.load('Woody.mtl', function (materials) {
	                materials.preload();
	                var objLoader = new THREE.OBJLoader();
	                objLoader.setMaterials(materials);
	                objLoader.setPath('assets/');
	                objLoader.load('Woody.obj', function (object) {
						/*Applying the woody matrix in woody obj*/
						object.position.set(-290, 0, -250);
	                	object.scale.x = object.scale.y = object.scale.z = 50;
	                	//object.applyMatrix(matrixWoody);
	                    object.rotation.x = -50;
			      		scene.add( object );
			      		obj_Woody = object;
	                });
            	});
				// Inserção do objeto Bullseye
				/*loader = new THREE.JSONLoader();
				loader.load('assets/balaNoAlvo.json', addModel);*/
				var mtlLoader2 = new THREE.MTLLoader();
				mtlLoader2.setPath('assets/');
				mtlLoader2.load('andando.mtl', function( materials ){
					materials.preload();
					var objLoader1 = new THREE.OBJLoader();
					objLoader1.setMaterials( materials );
					objLoader1.setPath('assets/');
					objLoader1.load('andando.obj', function( object ){
							object.position.set(120, 0, -80);
								scene.add( object );
								object.scale.x = object.scale.y = object.scale.z = 20;
								obj_Bull = object;
								obj_Bull.rotation.y += 0.05;
					});
				});
				/*new THREE.ObjectLoader().load( 'assets/balaNoAlvo.json', function ( loadedObject ) {
					loadedObject.traverse( function ( child ) {
						if ( child instanceof THREE.SkinnedMesh ) {
							mesh = child;
						}
					} );
					if ( mesh === undefined ) {
						alert( 'Unable to find a SkinnedMesh in this place:\n\n' + 'assets/balaNoAlvo.json' + '\n\n' );
						return;
					}
					mesh.rotation.y = - 135 * Math.PI / 180;
					scene.add( mesh );
					skeleton = new THREE.SkeletonHelper( mesh );
					skeleton.visible = false;
					scene.add( skeleton );
				});*/
				/*var loader = new THREE.JSONLoader();
				// load a resource
				loader.load('assets/balaNoAlvo.json', function (geometry, materials){
						var material = materials[0];
						var object = new THREE.Mesh(geometry, material);
						object.position.set(120, 0, -80);
						scene.add(object);
					}
				);*/
				var mtlLoader3 = new THREE.MTLLoader();
				mtlLoader3.setPath('assets/');
				mtlLoader3.load('LuxoBall.mtl', function( materials ){
					materials.preload();
					var objLoader2 = new THREE.OBJLoader();
					objLoader2.setMaterials( materials );
					objLoader2.setPath('assets/');
					objLoader2.load('LuxoBall.obj', function( object ){
						var BallMaterial = new THREE.ShaderMaterial({
							uniforms: {
								time: { value: 1.0 },
								resolution: { value: new THREE.Vector2() }
							},
				   			vertexShader: document.getElementById('vertex').innerHTML,
				   			fragmentShader: document.getElementById('fragment').innerHTML
						});
						object.traverse( function ( child ) {
				        	if ( child instanceof THREE.Mesh ) {
				            	child.material = BallMaterial;
				        	}
				    	});
				  		object.position.set(-0.3, -0.0, 0);
				  		object.scale.x = object.scale.y = object.scale.z = 200;
			      		scene.add( object );
			      		obj_Ball = object;
					});
				});
				var mtlLoader1 = new THREE.MTLLoader();
				mtlLoader1.setPath('assets/');
				mtlLoader1.load('Lotso.mtl', function( materials ){
					materials.preload();
					var loader = new THREE.OBJLoader();
					loader.setMaterials( materials );
					loader.load('assets/Lotso.obj',	function ( object ) {
				  		object.position.set(-200, 0, 30);
				  		object.scale.x = object.scale.y = object.scale.z = 45;
			      		scene.add( object );
			      		obj_Lotso = object;
					});
				});
				var cubeGeometry = new THREE.CubeGeometry(10,10,10);
				var wireMaterial = new THREE.MeshBasicMaterial( { transparent: true,opacity: 0} );
				MovingCube = new THREE.Mesh( cubeGeometry, wireMaterial );
				MovingCube.position.set(-290, 0, -250);
				scene.add( MovingCube );

				var cubeABC = new THREE.CubeGeometry( 45, 45, 45);
				var material = [
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/A.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}), 
			    ];
				var A = new THREE.Mesh( cubeABC, material );
				A.position.set(0, 10, -215);
				scene.add(A);
				ObjetosDeColisao.push(A);

				material = [
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/B.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}), 
			    ];
				var B = new THREE.Mesh( cubeABC, material);
				B.position.set(-45, 10, -230);
				scene.add(B);
				ObjetosDeColisao.push(B);
				material = [
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/C.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}), 
			    ];
				var C = new THREE.Mesh( cubeABC, material );
				C.position.set(-10, 50, -232);
				scene.add(C);
				
				/*Creating the renderer variable*/
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				container.appendChild(renderer.domElement);
				window.addEventListener('resize', onWindowResize, false);
				/*controls = new THREE.PointerLockControls(obj_Woody);
				scene.add(controls.getObject());*/
			}
			function addModel(geometry, materials){
				materials.forEach(function (mat){
					mat.skinning = true;
				});
				bala = new THREE.SkinnedMesh(geometry, new THREEMeshFaceMaterial(materials));
				walk = new THREE.Animation(bala, geometry.animations[0], handler);
				walk.play();
				scene.add(bala);
			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function animate() {
				requestAnimationFrame( animate );
				move_lotso();
				moving_woody();
				//var delta = clock.getDelta();
				//THREE.AnimationHandler.update(delta);
				moving_bull();
				render();
			}
			function moving_bull(){
			}
			function detection_colision_woody(direcao){
				var originPoint = MovingCube.clone();
				
				/*for (var vertexIndex = 0; vertexIndex < MovingCube.geometry.vertices.length; vertexIndex++)
				{		
					var localVertex = MovingCube.geometry.vertices[vertexIndex].clone();
					var globalVertex = localVertex.applyMatrix4( MovingCube.matrix );
					var directionVector = globalVertex.sub( MovingCube.position );
					
					var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
					var collisionResults = ray.intersectObjects( ObjetosDeColisao);
					if(collisionResults.length > 0){
						//console.log(collisionResults[0].distance);
					}
					if ( collisionResults.length > 0) {
						//console.log('aqui');
						return true;
					}
				}*/
				//alert(originPoint.position.x);
				if(direcao == moveForward){
					moveBackward = false;
					moveLeft = false;
					moveRight = false;
				} else if(direcao == moveBackward){
					moveForward = false;
					moveLeft = false;
					moveRight = false;
				} else if(direcao == moveLeft){
					moveForward = false;
					moveBackward = false;
					moveRight = false;
				} else if (direcao == moveRight){
					moveForward = false;
					moveBackward = false;
					moveLeft = false;
				}
				 
				for (var i = 0 ; i < ObjetosDeColisao.length ; i++){
					if(15 > distancePointToPoint(originPoint.position, ObjetosDeColisao[i].position)){
						return true;
					}
				}
				
				return false;	
			}
			function distancePointToPoint(point, sphere) {
				//alert(sphere.x);
			  	var dx = point.x - sphere.x;
				var dz = point.z - sphere.z;
				var distance = Math.sqrt(dx * dx + dz * dz);
			 
			 //alert(distance);
				return distance;
			  /*if(distance < 30){
			  	console.log(distance);
			  }*/
			
			}
			function moving_woody(){
				document.addEventListener("keydown", onDocumentKeyDown, false);
				function onDocumentKeyDown(event) {
					var delta = clock.getDelta();
					var moveDistance = 100 * delta;
				    var keyCode = event.which;
				    
				    if (keyCode == 83 && !moveBackward) { //s
				        obj_Woody.position.z += ySpeed;
				     //   obj_Bull.position.z += ySpeed;
				        MovingCube.position.z = obj_Woody.position.z; 
				       moveBackward = detection_colision_woody(moveBackward);
				    
				    } else if (keyCode == 87 && (obj_Woody.position.z> -250) && !moveForward) { //w
				        obj_Woody.position.z -= ySpeed;
				    //    obj_Bull.position.z -= ySpeed;
				          MovingCube.position.z = obj_Woody.position.z; 
				        moveForward = detection_colision_woody(moveForward);
				      
				    } else if (keyCode == 65 && obj_Woody.position.x > -290 && !moveLeft) { //a
				        obj_Woody.position.x -= xSpeed;
				    //    obj_Bull.position.x += xSpeed;
				        MovingCube.position.x = obj_Woody.position.x; 
				        moveLeft = detection_colision_woody(moveLeft);
				    } else if (keyCode == 68 && obj_Woody.position.x <290 && !moveRight) {//d
				        obj_Woody.position.x += xSpeed;
				   //     obj_Bull.position.x -= xSpeed;
				          MovingCube.position.x = obj_Woody.position.x; 
				        moveRight = detection_colision_woody(moveRight);
				    } else if (keyCode == 32) { //space
				        obj_Woody.position.set(-290, 0, -250);
				    //    obj_Bull.position.set(120, 0, -80);
				          MovingCube.position.set(-290, 0, -250);
				    }
				    							
				};
			}
			function move_lotso(){
				//count = 0;
				obj_Lotso.position.x = -100 + pontos.vertices[count].x * 10;
				obj_Lotso.position.y = pontos.vertices[count].y * 10;
				obj_Lotso.position.z = pontos.vertices[count].z * 10;
				obj_Lotso.rotation.y += 0.05;
				if (count == 99)
					flag_lotso = false;
				else if (count == 0)
					flag_lotso = true;
				if (flag_lotso == true)
					count++;
				else
					count--;
			}
			function render() {
				obj_Woody.rotation.y += 0.03;
				obj_Ball.rotation.x += 0.05;
				/*Getting the value from the button to change the camera*/
				document.getElementById('ButtonCamera1').onclick = function(){
					camera = camera1;
				}
				document.getElementById('ButtonCamera2').onclick = function(){
					camera = camera2;
				}
				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>