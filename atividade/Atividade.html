<!-- Nomes: Caio Henrique Giacomelli		RAs: 620360
	 		Gabriela Ramos						 620360
			Ricardo Mendes Leal Junior		     562262 -->

<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Atividade Final- Computaçao Gráfica</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<script src="three.js"></script>
		<script src="MTLLoader.js"></script>
		<script src="OBJLoader.js"></script>


		<script id="vertex" type="x-shader/x-vertex">
		     varying vec2 vUv;
			void main()
			{
				vUv = uv;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;
			}
		</script>

		<script id="fragment" type="x-shader/x-fragment">
			uniform vec2 resolution;
			varying vec2 vUv;
			void main( void ) {
				vec2 position = -25.0 + 3.0 * vUv;
				float red = abs( sin( position.x * position.y ) );
				float green = abs( sin( position.x * position.y ) );
				float blue = abs( sin( position.x * position.y) );
				gl_FragColor = vec4( red, green, blue, 1.0 );
			}
    	</script>

		<button id= "ButtonCamera1">Camera 1</button>
		<button id= "ButtonCamera2">Camera 2</button>
		<script>
			/*Declaring variables*/
			var container, stats;
			var camera2, scene, renderer;
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			var obj_Woody;
			var obj_Lotso;
			var obj_Ball;
			var MovingCube;
			var bezier_curve;
			var count = 0, flag_lotso = true;
			var UNITWIDTH = 90;
			var UNITHEIGHT = 45;
			var ObjetosDeColisao = [];
			var mixer;
			//var handler = THREE.AnimationHandler.CATMULLROM;
			var clock = new THREE.Clock();
			// Flags to determine which direction the player is moving
			var moveForward = false;
			var moveBackward = false;
			var moveLeft = false;
			var moveRight = false;
			var xSpeed = 0.01;
			var ySpeed = 0.01;
			var PLAYERCOLLISIONDISTANCE = 5;
			var skeleton, mesh;
			
			var actions;
			var settings;
			var idleAction;
			var walkAction;

			settings = {
					'modify idle weight':    1.0,
				};
    			init();
    			animate();
			function init(){
				/*Creating the new bezier curve*/
				bezier_curve = new THREE.CubicBezierCurve3(
					new THREE.Vector3(0, 0, 0),		//Starting point
					new THREE.Vector3(-30, 10, 0),		//First control point
					new THREE.Vector3(30, 0, 0),		//Second control point
					new THREE.Vector3(0, 0, 0)			//Ending point
				);
				pontos = new THREE.Geometry();
				pontos.vertices = bezier_curve.getPoints(100);
				matrixWoody = new THREE.Matrix4();
				matrixWoody.set(
					0.707106781187,  0.707106781187,  0,  1.414213562374,
       				-0.707106781187,  0.707106781187,  0,  -1.414213562374,
       				0,  0,  1,  0,
       				0,  0,  0,  1
       			);
				/*Creating the camera matrix*/
				matrixCamera = new THREE.Matrix4();
				matrixCamera.set(
					1, 0, 0, -0.25,
					0, 1, 0, -0.5,
					0, 0, 1, 100,
				 	0, 0, 0, 1
				);
				/*Creating the Container*/
				container = document.createElement('div');
				document.body.appendChild(container);
				/*Creating the Scene*/
				scene = new THREE.Scene();
				/*Creating the camera and positioning it*/
				camera1 = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 3000);
				camera = camera1;
				camera1.position.y = 580; // Height the camera will be looking from
			    camera1.position.x = 0;
			    camera1.position.z = 0;
			   	camera1.lookAt(scene.position);
				/*Utilizaçao de duas cameras */
				camera2 = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 3000);
				camera2.position.z = 480;
				camera2.position.y = 200;
				camera2.lookAt(new THREE.Vector3(0,0,0));
				/*Creating the ambient, light and adding it to the scene*/
				var ambient = new THREE.AmbientLight(0x444440);
				scene.add(ambient);
				var directionalLight = new THREE.DirectionalLight(0xffeedd);
				directionalLight.position.set(0, 1, 1).normalize();
				scene.add( directionalLight );
				/*Criando o labirinto*/
								var map = [
			        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1,1,1,1,1,],
			        [1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,1,1,1,1,1,],
			      	[1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1,1,0,0,1,],
			        [1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,0,0,1,1,1,],
			        [1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1,0,0,1,1,],
			      	[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,1,1,1,1,1,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
		        	[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,],
			        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0,0,0,0,0,]
			    ];
			    var sphGeo = new THREE.SphereGeometry( 9, 100, 100 );
				var sphMat = new THREE.MeshBasicMaterial( {color: 0xffff00} );
			    var widthOffset = UNITWIDTH / 5;
			    var heightOffset = UNITHEIGHT / 5;
			   var totalSphWide = map[0].length;
			   /*Adding spheres where value is 1*/
			    for (var i = 0; i < totalSphWide; i++) {
			        for (var j = 0; j < map[i].length; j++) {
			            if (map[i][j]) {
			                var sphere = new THREE.Mesh( sphGeo, sphMat );
			                sphere.position.z = (i - totalSphWide / 2) * UNITWIDTH + widthOffset*43;
			                sphere.position.y = 0;
			                sphere.position.x = (j - 11) * 20;
			                scene.add(sphere);
							/*Adding the sphere for colision detection later*/
							ObjetosDeColisao.push(sphere);
			            }
			        }
			    }
				 var materials = [
		       new THREE.MeshLambertMaterial({
		           map: THREE.ImageUtils.loadTexture('assets/back_toyStory.jpg'),
		           side: THREE.BackSide
		       }),
		       new THREE.MeshLambertMaterial({
		           map: THREE.ImageUtils.loadTexture('assets/back_toyStory.jpg'),
		           side: THREE.BackSide
		       }),
		       new THREE.MeshLambertMaterial({
		           map: THREE.ImageUtils.loadTexture('assets/back_toyStory.jpg'),
		           side: THREE.BackSide
		       }),
		       new THREE.MeshLambertMaterial({
		           map: THREE.ImageUtils.loadTexture('assets/chao.jpg'),
		           side: THREE.BackSide
		       }),
		       new THREE.MeshLambertMaterial({
		           map: THREE.ImageUtils.loadTexture('assets/back_toyStory.jpg'),
		           side: THREE.BackSide
		       }),
		       new THREE.MeshLambertMaterial({
		           map: THREE.ImageUtils.loadTexture('assets/back_toyStory.jpg'),
		           side: THREE.BackSide
		       })
		    ];
			dice = new THREE.Mesh( new THREE.BoxGeometry( 950,950,950), materials );
				dice.position.set(0,400,-100);
				scene.add( dice );
				var mtlLoader = new THREE.MTLLoader();
    	    	mtlLoader.setPath('assets/');
            	mtlLoader.load('Woody.mtl', function (materials) {
	                materials.preload();
	                var objLoader = new THREE.OBJLoader();
	                objLoader.setMaterials(materials);
	                objLoader.setPath('assets/');
	                objLoader.load('Woody.obj', function (object) {
						/*Applying the woody matrix in woody obj*/
						object.position.set(-200, 0, -220);
	                	object.scale.x = object.scale.y = object.scale.z = 50;
	                	//object.applyMatrix(matrixWoody);
	                    object.rotation.x = -50;
			      		scene.add( object );
			      		obj_Woody = object;
	                });
            	});
	/*		// Inserção do objeto Bullseye
			var loader = new THREE.JSONLoader();
			 loader.load( "assets/bala_andando.json", addModelToScene );
		 // After loading JSON from our file, we add it to the scene
		 function addModelToScene( geometry, materials ) {
		   var material = new THREE.MeshFaceMaterial(materials);
		   model = new THREE.Mesh( geometry, material );
		   model.scale.x = model.scale.y = model.scale.z = 50;
		   model.position.set(100, 0, -250);
		   scene.add( model );
		  mixer = new THREE.AnimationMixer(model);
   		 idleAction = mixer.clipAction(geometry.animations[0]);
   		 console.log(geometry.animations[0]);
    	idleAction.play();
    		set = true;
		 }
*/

				new THREE.ObjectLoader().load( 'assets/bala_andando.json', function ( loadedObject ) {
				loadedObject.traverse( function ( child ) {
					if ( child instanceof THREE.SkinnedMesh ) {
						mesh = child;
					}
				} );
				
				// Add mesh and skeleton helper to scene
				mesh.position.x = 100;
				mesh.position.y = 0;
				mesh.position.z = -200;
				mesh.scale.x = mesh.scale.y = mesh.scale.z = 50;
				scene.add( mesh );
				skeleton = new THREE.SkeletonHelper( mesh );
				skeleton.visible = false;
				scene.add( skeleton );
			
				mixer = new THREE.AnimationMixer( mesh );
				
				//walkAction = mixer.clipAction('walk');
				idleAction = mixer.clipAction('walk');

				//actions = [ idleAction];
				//activateAllActions();
				
			
				idleAction.play();
				mixer.update(clock.getDelta());

			} );


				var mtlLoader3 = new THREE.MTLLoader();
				mtlLoader3.setPath('assets/');
				mtlLoader3.load('LuxoBall.mtl', function( materials ){
					materials.preload();
					var objLoader2 = new THREE.OBJLoader();
					objLoader2.setMaterials( materials );
					objLoader2.setPath('assets/');
					objLoader2.load('LuxoBall.obj', function( object ){
						var BallMaterial = new THREE.ShaderMaterial({
							uniforms: {
								time: { value: 1.0 },
								resolution: { value: new THREE.Vector2() }
							},
				   			vertexShader: document.getElementById('vertex').innerHTML,
				   			fragmentShader: document.getElementById('fragment').innerHTML
						});
						object.traverse( function ( child ) {
				        	if ( child instanceof THREE.Mesh ) {
				            	child.material = BallMaterial;
				        	}
				    	});
				  		object.position.set(-0.3, -0.0, 0);
				  		object.scale.x = object.scale.y = object.scale.z = 200;
			      		scene.add( object );
			      		obj_Ball = object;
					});
				});
				var mtlLoader1 = new THREE.MTLLoader();
				mtlLoader1.setPath('assets/');
				mtlLoader1.load('Lotso.mtl', function( materials ){
					materials.preload();
					var loader = new THREE.OBJLoader();
					loader.setMaterials( materials );
					loader.load('assets/Lotso.obj',	function ( object ) {
				  		object.position.set(40, 0, -110);
				  		object.rotation.y += -1.55;
				  		object.scale.x = object.scale.y = object.scale.z = 45;
			      		scene.add( object );
			      		obj_Lotso = object;
					});
				});
				var cubeGeometry = new THREE.CubeGeometry(10,10,10);
				var wireMaterial = new THREE.MeshBasicMaterial( { transparent: true,opacity: 0} );
				MovingCube = new THREE.Mesh( cubeGeometry, wireMaterial );
				MovingCube.position.set(-200, 0, -220);
				scene.add( MovingCube );
				var cubeABC = new THREE.CubeGeometry( 45, 45, 45);
				var material = [
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/A.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			    ];
				var A = new THREE.Mesh( cubeABC, material );
				A.position.set(0, 10, -215);
				scene.add(A);
				ObjetosDeColisao.push(A);
				material = [
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/B.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			    ];
				var B = new THREE.Mesh( cubeABC, material);
				B.position.set(-45, 10, -230);
				scene.add(B);
				ObjetosDeColisao.push(B);
				material = [
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/C.jpg')}),
			      new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('assets/image.jpg')}),
			    ];
				var C = new THREE.Mesh( cubeABC, material );
				C.position.set(-10, 50, -232);
				scene.add(C);
				/*Creating the renderer variable*/
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				container.appendChild(renderer.domElement);
				window.addEventListener('resize', onWindowResize, false);
				/*controls = new THREE.PointerLockControls(obj_Woody);
				scene.add(controls.getObject());*/
			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function animate() {
				requestAnimationFrame( animate );
				move_bolinha();
				moving_woody();
				render();
			}
			function ganhar(){
				var originPoint = MovingCube.clone();
				var winPoint = obj_Bull.clone(); //Colocar obj_Bull ou mesh.clone()
				if(15 > distancePointToPoint(originPoint.position, winPoint.position)){
					alert("Parabéns, você ganhou!!");
		          	return true;
				}
				return false;
			}
			function perder(){
				var originPoint = MovingCube.clone();
				var lossPoint = obj_Lotso.clone();
				if(50 > distancePointToPoint(originPoint.position, lossPoint.position)){
					alert("Fuja do Lotso, você perdeu!!!");
		          	return true;
				}
				return false;
			}
			function animate1() {
				idleWeight = idleAction.getEffectiveWeight();
				var mixerUpdateDelta = clock.getDelta()*90000;
				mixer.update( mixerUpdateDelta );
			}

				function activateAllActions() {
				setWeight( idleAction, settings[ 'modify idle weight' ] );
				
				actions.forEach( function ( action ) {
					action.startAt(50);
						console.log(action);

				} );
			}


			function setWeight( action, weight ) {
				action.enabled = true;
				action.setEffectiveTimeScale( 1 );
				action.setEffectiveWeight( weight );
			}
			
			function detection_colision_woody(direcao){
				var originPoint = MovingCube.clone();
				/*for (var vertexIndex = 0; vertexIndex < MovingCube.geometry.vertices.length; vertexIndex++)
				{
					var localVertex = MovingCube.geometry.vertices[vertexIndex].clone();
					var globalVertex = localVertex.applyMatrix4( MovingCube.matrix );
					var directionVector = globalVertex.sub( MovingCube.position );
					var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
					var collisionResults = ray.intersectObjects( ObjetosDeColisao);
					if(collisionResults.length > 0){
						//console.log(collisionResults[0].distance);
					}
					if ( collisionResults.length > 0) {
						//console.log('aqui');
						return true;
					}
				}*/
				//alert(originPoint.position.x);
				if(direcao == moveForward){
					moveBackward = false;
					moveLeft = false;
					moveRight = false;
				} else if(direcao == moveBackward){
					moveForward = false;
					moveLeft = false;
					moveRight = false;
				} else if(direcao == moveLeft){
					moveForward = false;
					moveBackward = false;
					moveRight = false;
				} else if (direcao == moveRight){
					moveForward = false;
					moveBackward = false;
					moveLeft = false;
				}
				for (var i = 0 ; i < ObjetosDeColisao.length ; i++){
					if(15 > distancePointToPoint(originPoint.position, ObjetosDeColisao[i].position)){
						return true;
					}
				}
				return false;
			}
			function distancePointToPoint(point, sphere) {
				//alert(sphere.x);
			  	var dx = point.x - sphere.x;
				var dz = point.z - sphere.z;
				var distance = Math.sqrt(dx * dx + dz * dz);
				return distance;
			}
			function activateAllActions() {
				setWeight( idleAction, settings[ 'modify idle weight' ] );
				actions.forEach( function ( action ) {
					action.play();
					console.log(action);
				} );
			}
			function setWeight( action, weight ) {
				action.enabled = true;
				action.setEffectiveTimeScale( 1 );
				action.setEffectiveWeight( weight );
			}
			function moving_woody(){
				document.addEventListener("keydown", onDocumentKeyDown, false);
				function onDocumentKeyDown(event) {
					var delta = clock.getDelta();
					var moveDistance = 100 * delta;
				    var keyCode = event.which;
				    if (keyCode == 83 && !moveBackward) { //s
				        obj_Woody.position.z += ySpeed;
				     //   obj_Bull.position.z += ySpeed;
				        MovingCube.position.z = obj_Woody.position.z;
				       moveBackward = detection_colision_woody(moveBackward);
				    } else if (keyCode == 87 && (obj_Woody.position.z> -230) && !moveForward) { //w
				        obj_Woody.position.z -= ySpeed;
				    //    obj_Bull.position.z -= ySpeed;
				          MovingCube.position.z = obj_Woody.position.z;
				        moveForward = detection_colision_woody(moveForward);
				    } else if (keyCode == 65 && obj_Woody.position.x > -220 && !moveLeft) { //a
				        obj_Woody.position.x -= xSpeed;
				    //    obj_Bull.position.x += xSpeed;
				        MovingCube.position.x = obj_Woody.position.x;
				        moveLeft = detection_colision_woody(moveLeft);
				    } else if (keyCode == 68 && obj_Woody.position.x < 230&& !moveRight) {//d
				        obj_Woody.position.x += xSpeed;
				   //     obj_Bull.position.x -= xSpeed;
				          MovingCube.position.x = obj_Woody.position.x;
				        moveRight = detection_colision_woody(moveRight);
				    } else if (keyCode == 32) { //space
				        obj_Woody.position.set(-200, 0, -220);
				    //    obj_Bull.position.set(120, 0, -80);
				          MovingCube.position.set(-200, 0, -220);
				    }
				    /*if(ganhar()){
				    	obj_Woody.position.set(-290, 0, -250);
				    	MovingCube.position.set(-290, 0, -250);
				    }*/
				    if(perder()){
				    	obj_Woody.position.set(-200, 0, -220);
				    	MovingCube.position.set(-200, 0, -220);
				    }
				};
			}
			function move_bolinha(){
				//count = 0;
				obj_Ball.position.x = -10 + pontos.vertices[count].x * 10;
				obj_Ball.position.y = pontos.vertices[count].y * 10;
				obj_Ball.position.z = -30 + pontos.vertices[count].z * 10;
				obj_Ball.rotation.y += 0.05;
				if (count == 99)
					flag_lotso = false;
				else if (count == 0)
					flag_lotso = true;
				if (flag_lotso == true)
					count++;
				else
					count--;
			}
			function render() {
				obj_Woody.rotation.y += 0.03;
				/*Getting the value from the button to change the camera*/
				document.getElementById('ButtonCamera1').onclick = function(){
					camera = camera1;
				}
				document.getElementById('ButtonCamera2').onclick = function(){
					camera = camera2;
				}
    			renderer.render(scene, camera);
			}
		</script>
	</body>
</html>